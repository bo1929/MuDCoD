<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>mudcod.network_distances API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mudcod.network_distances</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import networkx as nx
import numpy as np
from numpy import linalg as LA
from scipy.integrate import quad
from scipy.linalg import eigh
from scipy.sparse import csgraph
from scipy.spatial import distance
from sklearn.metrics.cluster import adjusted_rand_score

_eps = 10 ** (-5)


def _assert_before_distance(adj1, adj2):
    assert adj1.ndim == 2 and adj2.ndim == 2
    assert adj1.shape == adj2.shape
    assert adj1.shape[0] == adj1.shape[1]
    assert adj2.shape[0] == adj2.shape[1]


class Distances:
    @staticmethod
    def community_membership_distance(z1, z2):
        return 1 - adjusted_rand_score(z1, z2)

    @staticmethod
    def exact_edit_distance(adj1, adj2):
        G1 = nx.from_numpy_array(adj1.astype(int))
        G2 = nx.from_numpy_array(adj2.astype(int))
        dist = nx.graph_edit_distance(G1, G2)
        return dist

    @staticmethod
    def optimized_edit_distance(adj1, adj2):
        G1 = nx.from_numpy_array(adj1.astype(int))
        G2 = nx.from_numpy_array(adj2.astype(int))
        minv = np.inf
        for v in nx.optimize_graph_edit_distance(G1, G2):
            minv = v
        return minv

    @staticmethod
    def hamming_distance(adj1, adj2, normalize=False):
        _assert_before_distance(adj1, adj2)
        n = adj1.shape[0]
        dist = np.sum(np.abs(adj1 - adj2))
        if normalize:
            dist = dist / (n * (n - 1))
        else:
            pass
        return dist

    @staticmethod
    def jaccard_distance(adj1, adj2):
        _assert_before_distance(adj1, adj2)
        dist = 1 - np.sum(np.minimum(adj1, adj2)) / np.sum(np.maximum(adj1, adj2))
        return dist

    @staticmethod
    def frobenius_distance(adj1, adj2):
        _assert_before_distance(adj1, adj2)
        dist = LA.norm(adj1 - adj2, ord=&#34;fro&#34;)
        return dist

    @staticmethod
    def communicability_jensenshannon(adj1, adj2):
        &#34;&#34;&#34;
        author: Brennan Klein
        Submitted as part of the 2019 NetSI Collabathon.
        &#34;&#34;&#34;
        G1 = nx.from_numpy_array(adj1.astype(int))
        G2 = nx.from_numpy_array(adj2.astype(int))

        N1 = G1.number_of_nodes()
        N2 = G2.number_of_nodes()

        C1 = nx.communicability_exp(G1)
        C2 = nx.communicability_exp(G2)

        Ca1 = np.zeros((N1, N1))
        Ca2 = np.zeros((N2, N2))

        for i in range(Ca1.shape[0]):
            Ca1[i] = np.array(list(C1[i].values()))
        for i in range(Ca2.shape[0]):
            Ca2[i] = np.array(list(C2[i].values()))

        lil_sigma1 = np.triu(Ca1).flatten()
        lil_sigma2 = np.triu(Ca2).flatten()

        big_sigma1 = sum(lil_sigma1[np.nonzero(lil_sigma1)[0]])
        big_sigma2 = sum(lil_sigma2[np.nonzero(lil_sigma2)[0]])

        P1 = lil_sigma1 / big_sigma1
        P2 = lil_sigma2 / big_sigma2
        P1 = np.array(sorted(P1))
        P2 = np.array(sorted(P2))

        dist = distance.jensenshannon(P1, P2)

        return dist

    @staticmethod
    def ipsen_mikhailov_distance(adj1, adj2, hwhm=0.08):
        &#34;&#34;&#34;
        author: Guillaume St-Onge
        Submitted as part of the 2019 NetSI Collabathon.
        &#34;&#34;&#34;
        _assert_before_distance(adj1, adj2)
        N = adj1.shape[0]
        # Get the Laplacian matrix.
        L1 = csgraph.laplacian(adj1, normed=False)
        L2 = csgraph.laplacian(adj2, normed=False)

        # Get the modes for the positive-semidefinite Laplacian.
        w1 = np.sqrt(np.abs(eigh(L1)[0][1:]))
        w2 = np.sqrt(np.abs(eigh(L2)[0][1:]))

        # Calculate the norm for both spectrum.
        norm1 = (N - 1) * np.pi / 2 - np.sum(np.arctan(-w1 / hwhm))
        norm2 = (N - 1) * np.pi / 2 - np.sum(np.arctan(-w2 / hwhm))

        # Define both spectral densities.
        density1 = (
            lambda w: np.sum(hwhm / ((w - w1) ** 2 + hwhm**2)) / norm1
        )  # noqa: E731
        density2 = (
            lambda w: np.sum(hwhm / ((w - w2) ** 2 + hwhm**2)) / norm2
        )  # noqa: E731

        func = lambda w: (density1(w) - density2(w)) ** 2  # noqa: E731

        return np.sqrt(quad(func, 0, np.inf, limit=100)[0])

    @staticmethod
    def polynomial_dissimilarity(adj1, adj2, k=5, alpha=1):
        &#34;&#34;&#34;
        Author: Jessica T. Davis
        Submitted as part of the 2019 NetSI Collabathon.
        &#34;&#34;&#34;

        def similarity_score(adj, k, alpha):
            &#34;&#34;&#34;
            Calculate the similarity score used in the polynomial dissimilarity
            distance. This uses a polynomial transformation of the eigenvalues
            of the of the adjacency matrix in combination with the eigenvectors
            of the adjacency matrix. See p. 27 of Donnat and Holmes (2018).
            &#34;&#34;&#34;

            eig_vals, Q = np.linalg.eig(adj)

            n = adj.shape[0]

            def polynomial(kp):
                return eig_vals**kp / (n - 1) ** (alpha * (kp - 1))

            W = np.diag(sum([polynomial(k) for k in range(1, k + 1)]))
            P_A = np.dot(np.dot(Q, W), Q.T)

            return P_A

        P_adj1 = similarity_score(adj1, k, alpha)
        P_adj2 = similarity_score(adj2, k, alpha)

        dist = np.linalg.norm(P_adj1 - P_adj2, ord=&#34;fro&#34;) / adj1.shape[0] ** 2

        return dist</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mudcod.network_distances.Distances"><code class="flex name class">
<span>class <span class="ident">Distances</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Distances:
    @staticmethod
    def community_membership_distance(z1, z2):
        return 1 - adjusted_rand_score(z1, z2)

    @staticmethod
    def exact_edit_distance(adj1, adj2):
        G1 = nx.from_numpy_array(adj1.astype(int))
        G2 = nx.from_numpy_array(adj2.astype(int))
        dist = nx.graph_edit_distance(G1, G2)
        return dist

    @staticmethod
    def optimized_edit_distance(adj1, adj2):
        G1 = nx.from_numpy_array(adj1.astype(int))
        G2 = nx.from_numpy_array(adj2.astype(int))
        minv = np.inf
        for v in nx.optimize_graph_edit_distance(G1, G2):
            minv = v
        return minv

    @staticmethod
    def hamming_distance(adj1, adj2, normalize=False):
        _assert_before_distance(adj1, adj2)
        n = adj1.shape[0]
        dist = np.sum(np.abs(adj1 - adj2))
        if normalize:
            dist = dist / (n * (n - 1))
        else:
            pass
        return dist

    @staticmethod
    def jaccard_distance(adj1, adj2):
        _assert_before_distance(adj1, adj2)
        dist = 1 - np.sum(np.minimum(adj1, adj2)) / np.sum(np.maximum(adj1, adj2))
        return dist

    @staticmethod
    def frobenius_distance(adj1, adj2):
        _assert_before_distance(adj1, adj2)
        dist = LA.norm(adj1 - adj2, ord=&#34;fro&#34;)
        return dist

    @staticmethod
    def communicability_jensenshannon(adj1, adj2):
        &#34;&#34;&#34;
        author: Brennan Klein
        Submitted as part of the 2019 NetSI Collabathon.
        &#34;&#34;&#34;
        G1 = nx.from_numpy_array(adj1.astype(int))
        G2 = nx.from_numpy_array(adj2.astype(int))

        N1 = G1.number_of_nodes()
        N2 = G2.number_of_nodes()

        C1 = nx.communicability_exp(G1)
        C2 = nx.communicability_exp(G2)

        Ca1 = np.zeros((N1, N1))
        Ca2 = np.zeros((N2, N2))

        for i in range(Ca1.shape[0]):
            Ca1[i] = np.array(list(C1[i].values()))
        for i in range(Ca2.shape[0]):
            Ca2[i] = np.array(list(C2[i].values()))

        lil_sigma1 = np.triu(Ca1).flatten()
        lil_sigma2 = np.triu(Ca2).flatten()

        big_sigma1 = sum(lil_sigma1[np.nonzero(lil_sigma1)[0]])
        big_sigma2 = sum(lil_sigma2[np.nonzero(lil_sigma2)[0]])

        P1 = lil_sigma1 / big_sigma1
        P2 = lil_sigma2 / big_sigma2
        P1 = np.array(sorted(P1))
        P2 = np.array(sorted(P2))

        dist = distance.jensenshannon(P1, P2)

        return dist

    @staticmethod
    def ipsen_mikhailov_distance(adj1, adj2, hwhm=0.08):
        &#34;&#34;&#34;
        author: Guillaume St-Onge
        Submitted as part of the 2019 NetSI Collabathon.
        &#34;&#34;&#34;
        _assert_before_distance(adj1, adj2)
        N = adj1.shape[0]
        # Get the Laplacian matrix.
        L1 = csgraph.laplacian(adj1, normed=False)
        L2 = csgraph.laplacian(adj2, normed=False)

        # Get the modes for the positive-semidefinite Laplacian.
        w1 = np.sqrt(np.abs(eigh(L1)[0][1:]))
        w2 = np.sqrt(np.abs(eigh(L2)[0][1:]))

        # Calculate the norm for both spectrum.
        norm1 = (N - 1) * np.pi / 2 - np.sum(np.arctan(-w1 / hwhm))
        norm2 = (N - 1) * np.pi / 2 - np.sum(np.arctan(-w2 / hwhm))

        # Define both spectral densities.
        density1 = (
            lambda w: np.sum(hwhm / ((w - w1) ** 2 + hwhm**2)) / norm1
        )  # noqa: E731
        density2 = (
            lambda w: np.sum(hwhm / ((w - w2) ** 2 + hwhm**2)) / norm2
        )  # noqa: E731

        func = lambda w: (density1(w) - density2(w)) ** 2  # noqa: E731

        return np.sqrt(quad(func, 0, np.inf, limit=100)[0])

    @staticmethod
    def polynomial_dissimilarity(adj1, adj2, k=5, alpha=1):
        &#34;&#34;&#34;
        Author: Jessica T. Davis
        Submitted as part of the 2019 NetSI Collabathon.
        &#34;&#34;&#34;

        def similarity_score(adj, k, alpha):
            &#34;&#34;&#34;
            Calculate the similarity score used in the polynomial dissimilarity
            distance. This uses a polynomial transformation of the eigenvalues
            of the of the adjacency matrix in combination with the eigenvectors
            of the adjacency matrix. See p. 27 of Donnat and Holmes (2018).
            &#34;&#34;&#34;

            eig_vals, Q = np.linalg.eig(adj)

            n = adj.shape[0]

            def polynomial(kp):
                return eig_vals**kp / (n - 1) ** (alpha * (kp - 1))

            W = np.diag(sum([polynomial(k) for k in range(1, k + 1)]))
            P_A = np.dot(np.dot(Q, W), Q.T)

            return P_A

        P_adj1 = similarity_score(adj1, k, alpha)
        P_adj2 = similarity_score(adj2, k, alpha)

        dist = np.linalg.norm(P_adj1 - P_adj2, ord=&#34;fro&#34;) / adj1.shape[0] ** 2

        return dist</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="mudcod.network_distances.Distances.communicability_jensenshannon"><code class="name flex">
<span>def <span class="ident">communicability_jensenshannon</span></span>(<span>adj1, adj2)</span>
</code></dt>
<dd>
<div class="desc"><p>author: Brennan Klein
Submitted as part of the 2019 NetSI Collabathon.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def communicability_jensenshannon(adj1, adj2):
    &#34;&#34;&#34;
    author: Brennan Klein
    Submitted as part of the 2019 NetSI Collabathon.
    &#34;&#34;&#34;
    G1 = nx.from_numpy_array(adj1.astype(int))
    G2 = nx.from_numpy_array(adj2.astype(int))

    N1 = G1.number_of_nodes()
    N2 = G2.number_of_nodes()

    C1 = nx.communicability_exp(G1)
    C2 = nx.communicability_exp(G2)

    Ca1 = np.zeros((N1, N1))
    Ca2 = np.zeros((N2, N2))

    for i in range(Ca1.shape[0]):
        Ca1[i] = np.array(list(C1[i].values()))
    for i in range(Ca2.shape[0]):
        Ca2[i] = np.array(list(C2[i].values()))

    lil_sigma1 = np.triu(Ca1).flatten()
    lil_sigma2 = np.triu(Ca2).flatten()

    big_sigma1 = sum(lil_sigma1[np.nonzero(lil_sigma1)[0]])
    big_sigma2 = sum(lil_sigma2[np.nonzero(lil_sigma2)[0]])

    P1 = lil_sigma1 / big_sigma1
    P2 = lil_sigma2 / big_sigma2
    P1 = np.array(sorted(P1))
    P2 = np.array(sorted(P2))

    dist = distance.jensenshannon(P1, P2)

    return dist</code></pre>
</details>
</dd>
<dt id="mudcod.network_distances.Distances.community_membership_distance"><code class="name flex">
<span>def <span class="ident">community_membership_distance</span></span>(<span>z1, z2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def community_membership_distance(z1, z2):
    return 1 - adjusted_rand_score(z1, z2)</code></pre>
</details>
</dd>
<dt id="mudcod.network_distances.Distances.exact_edit_distance"><code class="name flex">
<span>def <span class="ident">exact_edit_distance</span></span>(<span>adj1, adj2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def exact_edit_distance(adj1, adj2):
    G1 = nx.from_numpy_array(adj1.astype(int))
    G2 = nx.from_numpy_array(adj2.astype(int))
    dist = nx.graph_edit_distance(G1, G2)
    return dist</code></pre>
</details>
</dd>
<dt id="mudcod.network_distances.Distances.frobenius_distance"><code class="name flex">
<span>def <span class="ident">frobenius_distance</span></span>(<span>adj1, adj2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def frobenius_distance(adj1, adj2):
    _assert_before_distance(adj1, adj2)
    dist = LA.norm(adj1 - adj2, ord=&#34;fro&#34;)
    return dist</code></pre>
</details>
</dd>
<dt id="mudcod.network_distances.Distances.hamming_distance"><code class="name flex">
<span>def <span class="ident">hamming_distance</span></span>(<span>adj1, adj2, normalize=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def hamming_distance(adj1, adj2, normalize=False):
    _assert_before_distance(adj1, adj2)
    n = adj1.shape[0]
    dist = np.sum(np.abs(adj1 - adj2))
    if normalize:
        dist = dist / (n * (n - 1))
    else:
        pass
    return dist</code></pre>
</details>
</dd>
<dt id="mudcod.network_distances.Distances.ipsen_mikhailov_distance"><code class="name flex">
<span>def <span class="ident">ipsen_mikhailov_distance</span></span>(<span>adj1, adj2, hwhm=0.08)</span>
</code></dt>
<dd>
<div class="desc"><p>author: Guillaume St-Onge
Submitted as part of the 2019 NetSI Collabathon.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def ipsen_mikhailov_distance(adj1, adj2, hwhm=0.08):
    &#34;&#34;&#34;
    author: Guillaume St-Onge
    Submitted as part of the 2019 NetSI Collabathon.
    &#34;&#34;&#34;
    _assert_before_distance(adj1, adj2)
    N = adj1.shape[0]
    # Get the Laplacian matrix.
    L1 = csgraph.laplacian(adj1, normed=False)
    L2 = csgraph.laplacian(adj2, normed=False)

    # Get the modes for the positive-semidefinite Laplacian.
    w1 = np.sqrt(np.abs(eigh(L1)[0][1:]))
    w2 = np.sqrt(np.abs(eigh(L2)[0][1:]))

    # Calculate the norm for both spectrum.
    norm1 = (N - 1) * np.pi / 2 - np.sum(np.arctan(-w1 / hwhm))
    norm2 = (N - 1) * np.pi / 2 - np.sum(np.arctan(-w2 / hwhm))

    # Define both spectral densities.
    density1 = (
        lambda w: np.sum(hwhm / ((w - w1) ** 2 + hwhm**2)) / norm1
    )  # noqa: E731
    density2 = (
        lambda w: np.sum(hwhm / ((w - w2) ** 2 + hwhm**2)) / norm2
    )  # noqa: E731

    func = lambda w: (density1(w) - density2(w)) ** 2  # noqa: E731

    return np.sqrt(quad(func, 0, np.inf, limit=100)[0])</code></pre>
</details>
</dd>
<dt id="mudcod.network_distances.Distances.jaccard_distance"><code class="name flex">
<span>def <span class="ident">jaccard_distance</span></span>(<span>adj1, adj2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def jaccard_distance(adj1, adj2):
    _assert_before_distance(adj1, adj2)
    dist = 1 - np.sum(np.minimum(adj1, adj2)) / np.sum(np.maximum(adj1, adj2))
    return dist</code></pre>
</details>
</dd>
<dt id="mudcod.network_distances.Distances.optimized_edit_distance"><code class="name flex">
<span>def <span class="ident">optimized_edit_distance</span></span>(<span>adj1, adj2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def optimized_edit_distance(adj1, adj2):
    G1 = nx.from_numpy_array(adj1.astype(int))
    G2 = nx.from_numpy_array(adj2.astype(int))
    minv = np.inf
    for v in nx.optimize_graph_edit_distance(G1, G2):
        minv = v
    return minv</code></pre>
</details>
</dd>
<dt id="mudcod.network_distances.Distances.polynomial_dissimilarity"><code class="name flex">
<span>def <span class="ident">polynomial_dissimilarity</span></span>(<span>adj1, adj2, k=5, alpha=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Author: Jessica T. Davis
Submitted as part of the 2019 NetSI Collabathon.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def polynomial_dissimilarity(adj1, adj2, k=5, alpha=1):
    &#34;&#34;&#34;
    Author: Jessica T. Davis
    Submitted as part of the 2019 NetSI Collabathon.
    &#34;&#34;&#34;

    def similarity_score(adj, k, alpha):
        &#34;&#34;&#34;
        Calculate the similarity score used in the polynomial dissimilarity
        distance. This uses a polynomial transformation of the eigenvalues
        of the of the adjacency matrix in combination with the eigenvectors
        of the adjacency matrix. See p. 27 of Donnat and Holmes (2018).
        &#34;&#34;&#34;

        eig_vals, Q = np.linalg.eig(adj)

        n = adj.shape[0]

        def polynomial(kp):
            return eig_vals**kp / (n - 1) ** (alpha * (kp - 1))

        W = np.diag(sum([polynomial(k) for k in range(1, k + 1)]))
        P_A = np.dot(np.dot(Q, W), Q.T)

        return P_A

    P_adj1 = similarity_score(adj1, k, alpha)
    P_adj2 = similarity_score(adj2, k, alpha)

    dist = np.linalg.norm(P_adj1 - P_adj2, ord=&#34;fro&#34;) / adj1.shape[0] ** 2

    return dist</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mudcod" href="index.html">mudcod</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mudcod.network_distances.Distances" href="#mudcod.network_distances.Distances">Distances</a></code></h4>
<ul class="">
<li><code><a title="mudcod.network_distances.Distances.communicability_jensenshannon" href="#mudcod.network_distances.Distances.communicability_jensenshannon">communicability_jensenshannon</a></code></li>
<li><code><a title="mudcod.network_distances.Distances.community_membership_distance" href="#mudcod.network_distances.Distances.community_membership_distance">community_membership_distance</a></code></li>
<li><code><a title="mudcod.network_distances.Distances.exact_edit_distance" href="#mudcod.network_distances.Distances.exact_edit_distance">exact_edit_distance</a></code></li>
<li><code><a title="mudcod.network_distances.Distances.frobenius_distance" href="#mudcod.network_distances.Distances.frobenius_distance">frobenius_distance</a></code></li>
<li><code><a title="mudcod.network_distances.Distances.hamming_distance" href="#mudcod.network_distances.Distances.hamming_distance">hamming_distance</a></code></li>
<li><code><a title="mudcod.network_distances.Distances.ipsen_mikhailov_distance" href="#mudcod.network_distances.Distances.ipsen_mikhailov_distance">ipsen_mikhailov_distance</a></code></li>
<li><code><a title="mudcod.network_distances.Distances.jaccard_distance" href="#mudcod.network_distances.Distances.jaccard_distance">jaccard_distance</a></code></li>
<li><code><a title="mudcod.network_distances.Distances.optimized_edit_distance" href="#mudcod.network_distances.Distances.optimized_edit_distance">optimized_edit_distance</a></code></li>
<li><code><a title="mudcod.network_distances.Distances.polynomial_dissimilarity" href="#mudcod.network_distances.Distances.polynomial_dissimilarity">polynomial_dissimilarity</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>